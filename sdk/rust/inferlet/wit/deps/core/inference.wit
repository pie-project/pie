interface inference {

    use wasi:io/poll@0.2.4.{pollable};
    use types.{error};
    use context.{context};
    use model.{model};
    use adapter.{adapter};
    use context.{page-id};

    // binary run-length encoding
    type brle = list<u32>;

    resource forward-pass {
        constructor(model: borrow<model>);

        context: func(
            context: borrow<context>,
        );

        input-tokens: func(
            tokens: list<u32>,
            positions: list<u32>,
        );

        input-speculative-tokens: func(
            tokens: list<u32>,
            positions: list<u32>,
        );

        // if not provided, fallback to causal mask
        attention-mask: func(
            mask: list<brle>,
        );

        // if not provided, fallback to all ones (no masking)
        sampling-mask: func(
            mask: brle,
        );

        sampler: func(
            indices: list<u32>,
            sampler: sampler,
        );

        adapter: func(
            adapter: borrow<adapter>,
        );

        execute: func() -> result<future-output, error>;
    }

    variant sampler {
        multinomial(tuple<f32, u32>),
        top-k(tuple<f32, u32>),
        top-p(tuple<f32, f32>),
        min-p(tuple<f32, f32>),
        top-k-top-p(tuple<f32, u32, f32>),
        embedding,
        dist(tuple<f32, u32>),
    }

    resource future-output {
        // Returns a pollable object to check when the result is ready
        pollable: func() -> pollable;

        get: func() -> option<output>;

        get-speculative-tokens: func() -> option<list<tuple<u32, u32>>>;
    }

    variant output {
        none,
        tokens(list<u32>),
        embeddings(list<list<u8>>),
        distributions(list<tuple<list<u32>, list<f32>>>) // Each tuple: (token IDs, associated probabilities)
    }

}