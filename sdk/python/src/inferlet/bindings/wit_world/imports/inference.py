# This file is automatically generated by componentize-py
# It is not intended for manual editing.
from typing import TypeVar, Generic, Union, Optional, Protocol, Tuple, List, Any, Self, Callable
from types import TracebackType
from enum import Flag, Enum, auto
from dataclasses import dataclass
from abc import abstractmethod
import weakref

from componentize_py_types import Result, Ok, Err, Some
from ..imports import adapter
from ..imports import context
from ..imports import poll
from ..imports import model


@dataclass
class Sampler_Multinomial:
    value: Tuple[float, int]


@dataclass
class Sampler_TopK:
    value: Tuple[float, int]


@dataclass
class Sampler_TopP:
    value: Tuple[float, float]


@dataclass
class Sampler_MinP:
    value: Tuple[float, float]


@dataclass
class Sampler_TopKTopP:
    value: Tuple[float, int, float]


@dataclass
class Sampler_Embedding:
    pass


@dataclass
class Sampler_Dist:
    value: Tuple[float, int]


Sampler = Union[Sampler_Multinomial, Sampler_TopK, Sampler_TopP, Sampler_MinP, Sampler_TopKTopP, Sampler_Embedding, Sampler_Dist]



@dataclass
class Output_None_:
    pass


@dataclass
class Output_Tokens:
    value: List[int]


@dataclass
class Output_TokensWithSpeculation:
    value: Tuple[List[int], List[int], List[int]]


@dataclass
class Output_Embeddings:
    value: List[bytes]


@dataclass
class Output_Distributions:
    value: List[Tuple[List[int], List[float]]]


Output = Union[Output_None_, Output_Tokens, Output_TokensWithSpeculation, Output_Embeddings, Output_Distributions]


class FutureOutput:
    
    def pollable(self) -> poll.Pollable:
        """
        Returns a pollable object to check when the result is ready
        """
        raise NotImplementedError
    def get(self) -> Optional[Output]:
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self
                                
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError


class ForwardPass:
    
    def __init__(self, model: model.Model) -> None:
        raise NotImplementedError

    def context(self, context: context.Context) -> None:
        raise NotImplementedError
    def input_tokens(self, tokens: List[int], positions: List[int]) -> None:
        raise NotImplementedError
    def input_speculative_tokens(self, tokens: List[int], positions: List[int]) -> None:
        raise NotImplementedError
    def output_speculative_tokens(self, flag: bool) -> None:
        """
        enabled by default
        """
        raise NotImplementedError
    def attention_mask(self, mask: List[List[int]]) -> None:
        """
        if not provided, fallback to causal mask
        """
        raise NotImplementedError
    def logit_mask(self, mask: List[int]) -> None:
        """
        if not provided, fallback to all ones (no masking)
        """
        raise NotImplementedError
    def sampler(self, indices: List[int], sampler: Sampler) -> None:
        raise NotImplementedError
    def adapter(self, adapter: adapter.Adapter) -> None:
        raise NotImplementedError
    def execute(self) -> FutureOutput:
        """
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self
                                
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError


class Grammar:
    """
    Describes the structure that the LLM output must conform to.
    Constructed via static factory methods for each supported format.
    """
    
    @classmethod
    def from_json_schema(cls, schema: str) -> Self:
        """
        Construct from a JSON Schema string.
        
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    @classmethod
    def json(cls) -> Self:
        """
        Construct a built-in free-form JSON grammar (any valid JSON).
        """
        raise NotImplementedError
    @classmethod
    def from_regex(cls, pattern: str) -> Self:
        """
        Construct from a regular expression pattern.
        
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    @classmethod
    def from_ebnf(cls, ebnf: str) -> Self:
        """
        Construct from an EBNF grammar string.
        
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self
                                
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError


class Matcher:
    """
    Stateful matcher that walks the grammar automaton as tokens are
    accepted, producing a bitmask of valid next tokens at each step.
    The host compiles the grammar on construction and may cache the
    compiled result internally.
    """
    
    def __init__(self, grammar: Grammar, tokenizer: model.Tokenizer) -> None:
        """
        Create a new matcher from a grammar and tokenizer.
        """
        raise NotImplementedError

    def accept_tokens(self, token_ids: List[int]) -> None:
        """
        Accept one or more decoded tokens, advancing the matcher state.
        Returns an error if any token violates the grammar.
        
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def next_token_logit_mask(self) -> List[int]:
        """
        Fill the next-token bitmask.  The returned BRLE encodes which
        token ids in the vocabulary are allowed at the current position.
        """
        raise NotImplementedError
    def is_terminated(self) -> bool:
        """
        Check whether the matcher has reached a terminal state.
        """
        raise NotImplementedError
    def reset(self) -> None:
        """
        Reset the matcher to its initial state so it can be reused.
        """
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self
                                
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError



