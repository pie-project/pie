---
title: I/O & Messaging
description: HTTP client/server, file I/O, client messaging, broadcast/subscribe, and spawning inferlets
sidebar_position: 10
---

# I/O & Messaging

Inferlets run inside a WASI (WebAssembly System Interface) sandbox. WASI provides capability-based access to the outside world — HTTP networking, filesystem, and timers. Pie extends this with a messaging interface for inter-inferlet and client communication.

## HTTP Client

Fetch data from external services using `wstd::http::Client`:

```rust
use inferlet::wstd::http::{Client, Method, Request};
use inferlet::wstd::io::{AsyncRead, empty};

async fn fetch(url: &str) -> Result<Vec<u8>> {
    let client = Client::new();

    let request = Request::builder()
        .uri(url)
        .method(Method::GET)
        .body(empty())?;

    let response = client.send(request).await?;

    let mut body = response.into_body();
    let mut buf = Vec::new();
    body.read_to_end(&mut buf).await?;

    Ok(buf)
}
```

This enables inferlets to:
- Fetch documents, images, or data for context
- Call external APIs (e.g., search engines, databases)
- Download resources on demand

## HTTP Server

Inferlets can also serve HTTP requests using the `wasi:http/incoming-handler` interface. This is a different entry point from `#[inferlet::main]`:

```rust
use wstd::http::body::{BodyForthcoming, IncomingBody};
use wstd::http::server::{Finished, Responder};
use wstd::http::{IntoBody, Request, Response, StatusCode};
use wstd::io::AsyncWrite;

#[wstd::http_server]
async fn main(req: Request<IncomingBody>, res: Responder) -> Finished {
    let path = req.uri().path();

    match path {
        "/" => {
            res.respond(Response::new("Hello!".into_body())).await
        }
        _ => {
            let response = Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body("404".into_body())
                .unwrap();
            res.respond(response).await
        }
    }
}
```

Run an HTTP server inferlet:

```bash
pie http --path ./my-server.wasm --port 8080
```

### SSE Streaming

For streaming responses (e.g., Server-Sent Events), use `BodyForthcoming`:

```rust
let sse_response = Response::builder()
    .header("Content-Type", "text/event-stream")
    .header("Cache-Control", "no-cache")
    .body(BodyForthcoming)
    .unwrap();

let mut body = res.start_response(sse_response);

for i in 1..=5 {
    let event = format!("event: message\ndata: {{\"count\": {}}}\n\n", i);
    body.write_all(event.as_bytes()).await?;
    body.flush().await?;  // Push data to client immediately
    wstd::task::sleep(Duration::from_millis(100)).await;
}

Finished::finish(body, Ok(()), None)
```

## File I/O

WASI provides standard filesystem access:

```rust
use std::fs;

// Read a file
let contents = fs::read_to_string("/data/input.txt")?;

// Write a file
fs::write("/data/output.json", &json_bytes)?;
```

:::note
File access is sandboxed — inferlets can only access directories explicitly granted by the runtime.
:::

## Timers and Sleep

```rust
use wstd::time::{Duration, Instant};

// Sleep
wstd::task::sleep(Duration::from_secs(1)).await;

// Timing
let start = Instant::now();
// ... work ...
let elapsed = start.elapsed();
```

## Client Communication

Send and receive text messages with the connected client:

```rust
use inferlet::{messaging, FutureStringExt};

// Send a message to the client
messaging::send("Processing your request...");

// Receive a message from the client (async)
let future = messaging::receive();
let msg = future.wait_async().await;  // Option<String>
```

:::note
`receive()` returns a `FutureString` — a pollable async handle. Use the `FutureStringExt::wait_async()` extension trait to await it.
:::

The client SDK's `send()`/`recv()` methods correspond to these functions.

## Broadcast / Subscribe

One-to-many messaging where all subscribers receive every message:

```rust
use inferlet::{messaging, SubscriptionExt};

// Publisher: broadcast to all subscribers on a topic
messaging::broadcast("events", "new-data-available");

// Subscriber: subscribe to a topic
let subscription = messaging::subscribe("events");

// Poll for messages asynchronously
loop {
    if let Some(msg) = subscription.get_async().await {
        println!("Got event: {}", msg);
    }
}

// When done
subscription.unsubscribe();
```

Broadcast/subscribe enables event-driven coordination between inferlets — for example, notifying workers that new data is available.

## Spawning Inferlets

Launch child inferlets from within a running inferlet:

```rust
use inferlet::{runtime, FutureStringExt};

// Spawn a child inferlet by package name
let result = runtime::spawn("my-tool@0.1.0", &["--arg", "value"])?;

// Wait for its output
let output = result.wait_async().await;  // Option<String>
```

This enables pipelines where one inferlet delegates subtasks to others.

## Concurrency

Use `wstd::task::spawn` for concurrent operations within an inferlet:

```rust
use wstd::task;

// Spawn concurrent tasks
let handle = task::spawn(async {
    // ... concurrent work ...
    "result"
});
```

This is useful for parallel HTTP requests, concurrent generation streams, or background processing.

## Summary

| Pattern | When to use |
|---------|-------------|
| **HTTP Client** | Fetch external data, call APIs |
| **HTTP Server** | Serve HTTP/SSE endpoints from an inferlet |
| **File I/O** | Read/write sandboxed files |
| **Send / Receive** | Interactive client-inferlet communication |
| **Broadcast / Subscribe** | Event notifications, state sync across inferlets |
| **Spawn** | Delegate subtasks to other inferlets |

## Next Steps

- **[MCP Integration](./mcp)** — Connect to external tool servers
- **[Building & Publishing](./building-publishing)** — Package your inferlet
